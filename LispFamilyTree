;;;; -*- Mode: Lisp; -*- 
(print "Hello World")
(setf testCases (list '(E A B AB)))
(setf testCases(append testCases (list '(E A D AD))))
(setf testCases(append testCases (list '(E A C AC))))
(setf testCases(append testCases (list '(E C D CD))))
(setf testCases(append testCases (list '(E E F EF))))
(setf testCases(append testCases (list '(E G H GH))))
(setf testCases(append testCases (list '(E A E))))
(setf testCases(append testCases (list '(E I J IJ))))
(setf testCases(append testCases (list '(W A Spouse B))))
(setf testCases(append testCases (list '(W C Parent CD))))
(setf testCases(append testCases (list '(W AC Sibling AD))))
(setf testCases(append testCases (list '(W A Parent AC))))

(defun empty (input)
  (print input)
  )
(defun DummyFunction (person1 person2 person3 tree)
  (print person1)
  (print person2)
  (print person3)

  )
(defun isRelation (person1 relation person2 tree)
  ;(print relation)
  (if (string= relation "SPOUSE") (isSpouse person1 person2 tree) )
  (if (string= relation "PARENT") (isParent person1 person2 tree) )
  (if (string= relation "SIBLING") (isSibling person1 person2 tree) )
  )
(defun isSpouse (person1 person2 tree)
  ;(print "isSpouse function")
  ;(print (person-spouses (gethash person2 tree)))
 ; (print (person-name (gethash person2 tree)))
  ;(print person2)
  ;(print (person-spouses (gethash person1 tree)))
  (setf val "No")
  (if (member person1  (person-spouses (gethash person2 tree)) :test #'equal) (setf val "Yes"))
  (if (member person2  (person-spouses (gethash person1 tree)) :test #'equal) (setf val "Yes"))
  (print val)
  )
(defun isSibling (person1 person2 tree)
  (setf val "No")
  (loop for x in (person-parents (gethash person2 tree)) do(if (member x (person-parents (gethash person1 tree))) (setf val "Yes")))
  (print val)
  )
(defun isParent (person1 person2 tree)
  (setf val "No")
  (if (member person1  (person-parents (gethash person2 tree)) :test #'equal) (setf val "Yes"))
  (print val)
  )
(defun printAll (person1 relation)

  )
(defun childMarriage (person1 person2 person3 tree)
  (Marriage person1 person2 tree)
  (storeperson person3 (make-person :name person3) tree)
  (parent person3 person1 person2 tree)
  )
(defun Marriage (person1 person2 tree)
  (if (not (gethash person1 tree))
      (storeperson person1 (make-person :name person1) tree )
    )
  (if (not (gethash person2 tree))
      (storeperson person2 (make-person :name person2) tree )
    )
  (spouse person1 person2 tree)
  (spouse person2 person1 tree)
  )
(defstruct person 
  (name nil)
  (parents (list))
  (spouses (list)) 
  )
(defun spouse (person1 spouse tree)
  (setf (person-spouses (gethash person1 tree)) (cons spouse (person-spouses (gethash person1 tree))))
  (setf (person-spouses (gethash person1 tree)) (sort (person-spouses (gethash person1 tree)) #'string<))
  )
(defun parent (person1 parent1 parent2 tree)
  (setf (person-parents (gethash person1 tree)) (cons parent1 (person-parents (gethash person1 tree))))
  (setf (person-parents (gethash person1 tree)) (cons parent2 (person-parents (gethash person1 tree))))
  )

(defun person-name (input)
  ;bad touchie
  )
(defun storeperson (symbol-name struct family-tree)

  "Students need to write this! This should enter the person structure in STRUCT into the hashtable in FAMILY-TREE with the key in SYMBOL-NAME."
  
  (setf (gethash symbol-name family-tree) struct))



(defun personstruct (symbol-name family-tree)

  "Returns a structure of type person corresponding to the key SYMBOL-NAME in the hashtable FAMILY-TREE. If there is no one in the tree with the name in SYMBOL-NAME, returns NIL."

  (gethash symbol-name family-tree nil))



(defun ancestors (p tree)

  "Returns a list of symbol-names of all the ancestors of P in TREE. Does not remove any duplicated names!"

   (let ((parent1 (personstruct (first (person-parents p)) tree))

         (parent2 (personstruct (second (person-parents p)) tree)))

     (when parent1

         (append (list (person-name parent1) (person-name parent2))

                 (ancestors parent1 tree)

                 (ancestors parent2 tree)))))




(defun family ()

  "This is the top-level function for the whole Lisp program."

  (let ((tree (make-hash-table :size 1000 :test #'equal)))
    (print testCases)
    (loop for x in testCases 
             do ( 
             
             case (first x)
             (E (print x) (if (fourth x) (childMarriage (second x)(third x) (fourth x) tree) (Marriage (second x) (third x) tree)) 
                ;(if (not (fourth x)) (Marriage (second x) (third x) (tree)))
                )
             (W (print x) (isRelation (second x) (third x) (fourth x) tree))
             (X (print x))
             
             )
     )

; body of program goes in here!

    ))